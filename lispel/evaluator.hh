/*
 * (c) 1999-2001 by Michael Saure <MichaelSaure@web.de>
 * RCSID: $Id: evaluator.hh,v 1.2 2001/12/16 21:10:09 michael Exp $
 */

#ifndef _lispel_EVALUATOR_HH_
#define _lispel_EVALUATOR_HH_ 1

#include <stack>
#include <lispel/nodefactory.hh>
#include <lispel/environment.hh>
#include <lispel/exception.hh>
#include <lispel/context.hh>

/**
   Subclasses of Evaluator will usually process nodes returned by successive
   calls to some Lisp reader. The Evaluator in most general terms is some
   object that performs some processing on the graph-like structure composed
   by a reader and stored in a NodeFactory. The kind of processing performed
   by Evaluator instances can be, e.g., pretty-printing, compilation, direct
   evaluation, or whatever. So, if you want to turn the Lispel interpreter
   into a lispel pretty-printer, you just have to provide a new subclass of
   this class.<p>
   The current version of the evaluator maintains an explicit stack of
   binding environments to implement lexical binding (i.e. nested variable
   scopes). These methods have been added to compensate the lack of a 
   'real' activation stack. Once a proper implementation of an activation
   stack exists, the environment stack handling will be removed as it is 
   specific to recursive evaluator implementations.
   @version 0.2
*/
class Evaluator {
public:
  /// Creates a new evaluator for use in the given context.
  Evaluator( Context &ctx);
  virtual ~Evaluator();

  /**
     Depending on the type of the node passed to it, this method will either
     dispatch to one of the other eval* methods or it will return it's argument
     unchanged, thus implementing self-evaluating node types.
     @param node The node which is to be evaluated.
  */
  virtual Handle_ptr eval( Handle_ptr node) =0;

  /**
     During the evaluation phase all (unquoted) lists are treated as 
     s-expressions, which means that they will be executed as functions.
     This is what evalSExpression does. Before actually calling any code body,
     all arguments will be evaluated using calls to eval().
     @param node A CONS node which is to be evaluated as an s-expression.
  */
  virtual Handle_ptr evalExpression( Handle_ptr node)
    throw( RecoverableException) =0;

  /**
     Evaluation of a variable boils down to looking it up in the current
     environment.
   */
  virtual Handle_ptr evalVariable( Handle_ptr node)
    throw( UndefinedValue, InternalInconsistency) =0;

  /**
     Creates a new child environment the current environment.
     <b>NOTE:</b> This method is likely to vanish in one of the next versions.
     @return The newly allocated current environment.
   */
  virtual Environment *pushEnvironment();
  virtual void pushEnvironment( Environment *env);

  /**
     Removes the current environment from the environment stack. The
     environment won't be destroyed, so this is up to the caller.
     <b>NODE:</b> This method is likely to vanish soon.
  */
  virtual void popEnvironment();

  virtual Environment *currentEnvironment();

protected:
  Context &m_ctx;
  std::stack<Environment*> m_envStack;
};


/**
   This is an implementation of an direct evaluator, where direct means that
   the represenatation generated by the reader will be interpreted without
   any transformation to a more efficient intermediate bytecode or whatever.
   This definitely makes SimpleEvaluator a very slow type of Evaluator.
   The big advantage of this implementation is that it is very compact and
   simple in it's structure. So it yields some usable interpreter base quite
   fast.<p>
   SimpleEvaluator employs mutually recursive calls of the eval* methods to
   analyze an expression. I really would like to see how this performs
   compared to a solution using explicit stacks (HINT! HINT!).
*/
class SimpleEvaluator : public Evaluator {
public:
  explicit SimpleEvaluator( Context &ctx);
  virtual ~SimpleEvaluator();

  virtual Handle_ptr eval( Handle_ptr);
  virtual Handle_ptr evalExpression( Handle_ptr)
    throw( RecoverableException);
  virtual Handle_ptr evalVariable( Handle_ptr)
     throw( InternalInconsistency, UndefinedValue);
};


#endif /*_lispel_EVALUATOR_HH_*/
